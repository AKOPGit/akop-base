 (cd "$(git rev-parse --show-toplevel)" && git apply --3way <<'EOF'
diff --git a/resources/js/modules/rich-text-editor.js b/resources/js/modules/rich-text-editor.js
index 6659e1585491c507ac8d4b8df4faa5c8754fc8b5..847df9c2d20e367126e1356323f71b619ea4b601 100644
--- a/resources/js/modules/rich-text-editor.js
+++ b/resources/js/modules/rich-text-editor.js
@@ -1,33 +1,33 @@
 import {EditorState} from 'prosemirror-state'
 import {EditorView} from 'prosemirror-view'
 import {Schema, DOMParser as ProseParser, DOMSerializer} from 'prosemirror-model'
 import {schema as basicSchema} from 'prosemirror-schema-basic'
 import {addListNodes, wrapInList} from 'prosemirror-schema-list'
 import {history, undo, redo} from 'prosemirror-history'
 import {keymap} from 'prosemirror-keymap'
-import {baseKeymap, toggleMark, setBlockType, wrapIn} from 'prosemirror-commands'
+import {baseKeymap, toggleMark, setBlockType, wrapIn, chainCommands, exitCode} from 'prosemirror-commands'
 import {inputRules, textblockTypeInputRule} from 'prosemirror-inputrules'

 const underline = {
     parseDOM: [{tag: 'u'}, {style: 'text-decoration=underline'}],
     toDOM() { return ['u', 0] }
 }

 const strike = {
     parseDOM: [{tag: 's'}, {tag: 'del'}, {style: 'text-decoration=line-through'}],
     toDOM() { return ['s', 0] }
 }

 export function init() {
     document.querySelectorAll('[data-rich-text-editor]').forEach(container => {
         if (container.editor) return
         const targetId = container.id
         const hidden = document.querySelector(`[data-editor-target="${targetId}"]`)
         const value = hidden ? hidden.value : ''

         const nodes = addListNodes(basicSchema.spec.nodes, 'paragraph block*', 'block')
             .update('paragraph', {
                 content: 'inline*',
                 group: 'block',
                 attrs: {align: {default: 'left'}},
                 parseDOM: [{tag: 'p', getAttrs: dom => ({align: dom.style.textAlign || 'left'})}],
@@ -40,50 +40,63 @@ export function init() {
                 attrs: {level: {default: 1}, align: {default: 'left'}},
                 parseDOM: [
                     {tag: 'h1', getAttrs: dom => ({level:1, align: dom.style.textAlign || 'left'})},
                     {tag: 'h2', getAttrs: dom => ({level:2, align: dom.style.textAlign || 'left'})},
                     {tag: 'h3', getAttrs: dom => ({level:3, align: dom.style.textAlign || 'left'})},
                     {tag: 'h4', getAttrs: dom => ({level:4, align: dom.style.textAlign || 'left'})},
                     {tag: 'h5', getAttrs: dom => ({level:5, align: dom.style.textAlign || 'left'})},
                     {tag: 'h6', getAttrs: dom => ({level:6, align: dom.style.textAlign || 'left'})},
                 ],
                 toDOM(node) { return ['h'+node.attrs.level, {style: `text-align:${node.attrs.align}`}, 0] }
             })

         const marks = basicSchema.spec.marks
             .addBefore('link', 'underline', underline)
             .addToEnd('strike', strike)

         const schema = new Schema({nodes, marks})

         const parser = new DOMParser()
         const content = parser.parseFromString(value || '<p></p>', 'text/html')
         const state = EditorState.create({
             doc: ProseParser.fromSchema(schema).parse(content.body),
             plugins: [
                 history(),
                 inputRules({rules: buildInputRules(schema)}),
+                keymap({
+                    'Shift-Enter': chainCommands(
+                        exitCode,
+                        (state, dispatch) => {
+                            dispatch(
+                                state.tr.replaceSelectionWith(
+                                    state.schema.nodes.hard_break.create()
+                                ).scrollIntoView()
+                            )
+                            return true
+                        }
+                    )
+                }),
                 keymap(baseKeymap)
             ]
         })

         const view = new EditorView(container.querySelector('.editor'), {
             state,
             dispatchTransaction(tr){
                 const newState = view.state.apply(tr)
                 view.updateState(newState)
                 if(hidden){
                     hidden.value = getHTML(view.state.doc, schema)
                 }
             }
         })

         setupToolbar(container, schema, view)
         container.editor = view
     })
 }

 function setupToolbar(container, schema, view){
     container.querySelectorAll('[data-command]').forEach(btn => {
         const cmd = btn.getAttribute('data-command')
         if(cmd === 'heading'){
             btn.addEventListener('change', e => {

EOF
)
